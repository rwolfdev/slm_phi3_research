===== File: .\RWolfDev.Architecture.Mediator.csproj =====
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>


===== File: Abstracts\MediatorBase.cs =====
using RWolfDev.Architecture.Mediator.Interfaces;

using System.Reflection;

namespace RWolfDev.Architecture.Mediator.Abstracts
{
    /// <summary>
    /// Base implementation of the <see cref="IMediator"/> interface.
    /// Provides core functionality for sending requests and publishing notifications,
    /// including execution of pipeline behaviors.
    /// </summary>
    public abstract class MediatorBase : IMediator
    {
        /// <summary>
        /// Resolves a single handler instance from the underlying service provider.
        /// </summary>
        /// <param name="handlerType">The closed generic type of the handler to resolve.</param>
        /// <returns>An instance of the handler or null if not found.</returns>
        public abstract object? ResolveHandler(Type handlerType);

        /// <summary>
        /// Resolves all implementations of a service type (e.g., all pipeline behaviors).
        /// </summary>
        /// <param name="serviceType">The service type to resolve (can be generic).</param>
        /// <returns>An enumerable of resolved objects.</returns>
        public abstract IEnumerable<object> ResolveAll(Type serviceType);

        /// <summary>
        /// Sends a request to the appropriate handler and returns a response.
        /// Pipeline behaviors are applied around the handler.
        /// </summary>
        /// <typeparam name="TResponse">The type of the response.</typeparam>
        /// <param name="request">The request instance to process.</param>
        /// <param name="cancellationToken">Token for cooperative cancellation.</param>
        /// <returns>The response returned by the handler or composed by the pipeline.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the request is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown if no handler is found for the request.</exception>
        public async Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default)
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            // Determine the request and handler type
            Type requestType = request.GetType();
            Type handlerType = typeof(IRequestHandler<,>).MakeGenericType(requestType, typeof(TResponse));

            // Resolve the appropriate handler
            object? handler = ResolveHandler(handlerType);
            if (handler == null)
                throw new InvalidOperationException($"Handler for {requestType.Name} not found.");

            // Resolve all matching pipeline behaviors
            List<object> behaviors = ResolveAll(typeof(IPipelineBehavior<,>).MakeGenericType(requestType, typeof(TResponse))).ToList();

            // Build the final delegate starting with the handler itself
            Func<Task<TResponse>> handlerDelegate = () =>
            {
                MethodInfo handle = handlerType.GetMethod("Handle")!;
                object? task = handle.Invoke(handler, new object[] { request, cancellationToken });
                return (Task<TResponse>)task!;
            };

            // Wrap behaviors around the handler
            for (int i = behaviors.Count - 1; i >= 0; i--)
            {
                object behavior = behaviors[i];
                Func<Task<TResponse>> next = handlerDelegate;
                MethodInfo method = behavior.GetType().GetMethod("Handle")!;
                handlerDelegate = () =>
                {
                    object? task = method.Invoke(behavior, new object[] { request, cancellationToken, next });
                    return (Task<TResponse>)task!;
                };
            }

            // Execute the composed delegate chain
            return await handlerDelegate();
        }

        /// <summary>
        /// Publishes a notification to all registered handlers.
        /// All handlers are executed in parallel.
        /// </summary>
        /// <typeparam name="TNotification">The notification type.</typeparam>
        /// <param name="notification">The notification instance to publish.</param>
        /// <param name="cancellationToken">Token for cooperative cancellation.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task Publish<TNotification>(TNotification notification, CancellationToken cancellationToken = default)
            where TNotification : INotification
        {
            // Resolve all notification handlers
            IEnumerable<object> handlers = ResolveAll(typeof(INotificationHandler<TNotification>));

            // Execute each handler
            List<Task> tasks = new List<Task>();
            foreach (object handler in handlers)
            {
                INotificationHandler<TNotification> typedHandler = (INotificationHandler<TNotification>)handler;
                tasks.Add(typedHandler.Handle(notification, cancellationToken));
            }

            // Wait for all handlers to complete
            await Task.WhenAll(tasks);
        }
    }
}


===== File: Helper\HandlerRegistrationHelper.cs =====
using System.Reflection;

namespace RWolfDev.Architecture.Mediator.Helper
{
    /// <summary>
    /// Provides helper methods for discovering closed generic types 
    /// that implement a specific open generic interface or base type.
    /// </summary>
    public static class HandlerRegistrationHelper
    {
        /// <summary>
        /// Scans the given assemblies and returns all non-abstract, non-generic types
        /// that implement a closed version of the specified open generic interface.
        /// </summary>
        /// <param name="openGeneric">
        /// The open generic type definition to search for 
        /// (e.g., typeof(IRequestHandler<,>)).
        /// </param>
        /// <param name="assemblies">
        /// The assemblies to scan for implementations.
        /// </param>
        /// <returns>
        /// A sequence of types that implement a closed version of the given open generic type.
        /// </returns>
        /// <remarks>
        /// This method ignores abstract types and returns each matching type only once.
        /// </remarks>
        public static IEnumerable<Type> GetClosedTypes(Type openGeneric, IEnumerable<Assembly> assemblies)
        {
            foreach (Assembly assembly in assemblies)
            {
                foreach (Type type in assembly.GetTypes())
                {
                    // Skip abstract classes and generic type definitions
                    if (type.IsAbstract || type.IsGenericTypeDefinition)
                        continue;

                    foreach (Type interfaceType in type.GetInterfaces())
                    {
                        if (interfaceType.IsGenericType &&
                            interfaceType.GetGenericTypeDefinition() == openGeneric)
                        {
                            yield return type;
                            break; // No need to check other interfaces
                        }
                    }
                }
            }
        }
    }
}


===== File: Interfaces\IMediator.cs =====
namespace RWolfDev.Architecture.Mediator.Interfaces
{
    /// <summary>
    /// Defines a mediator abstraction that dispatches requests and publishes notifications
    /// to their respective handlers.
    /// </summary>
    public interface IMediator
    {
        /// <summary>
        /// Sends a request to a single matching handler and returns the response.
        /// </summary>
        /// <typeparam name="TResponse">The expected response type.</typeparam>
        /// <param name="request">The request object to send. Must not be null.</param>
        /// <param name="cancellationToken">Optional cancellation token to cancel the operation.</param>
        /// <returns>A task representing the asynchronous operation. The task result contains the handler’s response.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the request is null.</exception>
        Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default);

        /// <summary>
        /// Publishes a notification to all registered handlers of the notification type.
        /// All handlers will be executed asynchronously.
        /// </summary>
        /// <typeparam name="TNotification">The notification type.</typeparam>
        /// <param name="notification">The notification instance to publish. Must not be null.</param>
        /// <param name="cancellationToken">Optional cancellation token to cancel the operation.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the notification is null.</exception>
        Task Publish<TNotification>(TNotification notification, CancellationToken cancellationToken = default)
            where TNotification : INotification;
    }
}


===== File: Interfaces\INotification.cs =====
namespace RWolfDev.Architecture.Mediator.Interfaces
{
    /// <summary>
    /// Marker interface for notification messages that are published through the mediator.
    /// Implementing this interface allows a class to be handled by one or more
    /// <see cref="INotificationHandler{TNotification}"/> implementations.
    /// </summary>
    public interface INotification { }

    /// <summary>
    /// Defines a handler for a specific notification type.
    /// Implement this interface to handle published notifications.
    /// </summary>
    /// <typeparam name="TNotification">
    /// The type of notification to handle. Must implement <see cref="INotification"/>.
    /// </typeparam>
    public interface INotificationHandler<TNotification> where TNotification : INotification
    {
        /// <summary>
        /// Handles a notification asynchronously.
        /// </summary>
        /// <param name="notification">The notification instance. Must not be null.</param>
        /// <param name="cancellationToken">Optional token to cancel the operation.</param>
        /// <returns>A task representing the asynchronous handling operation.</returns>
        Task Handle(TNotification notification, CancellationToken cancellationToken);
    }
}


===== File: Interfaces\IPipelineBehavior.cs =====
namespace RWolfDev.Architecture.Mediator.Interfaces
{
    /// <summary>
    /// Defines a pipeline behavior that is executed before and/or after the request handler.
    /// Behaviors can be used for cross-cutting concerns such as logging, validation, transactions, etc.
    /// </summary>
    /// <typeparam name="TRequest">The type of the request message.</typeparam>
    /// <typeparam name="TResponse">The type of the response message.</typeparam>
    public interface IPipelineBehavior<TRequest, TResponse>
        where TRequest : IRequest<TResponse>
    {
        /// <summary>
        /// Handles the request and optionally invokes the next delegate in the pipeline.
        /// </summary>
        /// <param name="request">The request message being handled. Must not be null.</param>
        /// <param name="cancellationToken">A token to observe while waiting for the task to complete.</param>
        /// <param name="next">
        /// The next delegate in the pipeline, which represents either another behavior or the final handler.
        /// </param>
        /// <returns>
        /// A task that represents the asynchronous operation. The task result contains the response.
        /// </returns>
        Task<TResponse> Handle(
            TRequest request,
            CancellationToken cancellationToken,
            Func<Task<TResponse>> next);
    }
}


===== File: Interfaces\IRequest.cs =====
namespace RWolfDev.Architecture.Mediator.Interfaces
{
    /// <summary>
    /// Represents a request that expects a response.
    /// This is the base interface for command or query objects sent via <see cref="IMediator"/>.
    /// </summary>
    /// <typeparam name="TResponse">The type of the response returned by the handler.</typeparam>
    public interface IRequest<TResponse> { }

    /// <summary>
    /// Defines a handler for a specific type of request.
    /// </summary>
    /// <typeparam name="TRequest">
    /// The type of request being handled. Must implement <see cref="IRequest{TResponse}"/>.
    /// </typeparam>
    /// <typeparam name="TResponse">The type of response returned by the handler.</typeparam>
    public interface IRequestHandler<TRequest, TResponse>
        where TRequest : IRequest<TResponse>
    {
        /// <summary>
        /// Handles the specified request asynchronously and returns a response.
        /// </summary>
        /// <param name="request">The request instance to handle. Must not be null.</param>
        /// <param name="cancellationToken">A token to observe while waiting for the operation to complete.</param>
        /// <returns>
        /// A task representing the asynchronous operation. The task result contains the response.
        /// </returns>
        Task<TResponse> Handle(TRequest request, CancellationToken cancellationToken);
    }
}


